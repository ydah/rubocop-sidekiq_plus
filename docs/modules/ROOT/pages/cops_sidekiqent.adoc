////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= SidekiqEnt

[#sidekiqentencryptionwithmanyarguments]
== SidekiqEnt/EncryptionWithManyArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that encrypted jobs use proper argument structure.

Sidekiq Enterprise encryption only encrypts the last argument.
If sensitive data is passed in non-last arguments, it won't be encrypted.

[#examples-sidekiqentencryptionwithmanyarguments]
=== Examples

[source,ruby]
----
# bad - sensitive data not in last argument
class MyJob
  include Sidekiq::Job
  sidekiq_options encrypt: true

  def perform(password, user_id, options)
  end
end

# good - sensitive data in last argument (secret bag)
class MyJob
  include Sidekiq::Job
  sidekiq_options encrypt: true

  def perform(user_id, secret_bag)
  end
end
----

[#configurable-attributes-sidekiqentencryptionwithmanyarguments]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MaxArguments
| `2`
| Integer
|===

[#references-sidekiqentencryptionwithmanyarguments]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/EncryptionWithManyArguments

[#sidekiqentencryptionwithoutsecretbag]
== SidekiqEnt/EncryptionWithoutSecretBag

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that encrypted jobs have meaningful arguments to encrypt.

Sidekiq Enterprise encryption only encrypts the last argument.
If the job only has a single ID-like argument, encryption may
not provide much value.

[#examples-sidekiqentencryptionwithoutsecretbag]
=== Examples

[source,ruby]
----
# questionable - only ID argument
class MyJob
  include Sidekiq::Job
  sidekiq_options encrypt: true

  def perform(user_id)
  end
end

# good - secret data in last argument
class MyJob
  include Sidekiq::Job
  sidekiq_options encrypt: true

  def perform(user_id, secret_data)
  end
end
----

[#configurable-attributes-sidekiqentencryptionwithoutsecretbag]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Severity
| `info`
| String
|===

[#references-sidekiqentencryptionwithoutsecretbag]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/EncryptionWithoutSecretBag

[#sidekiqentleaderelectionwithoutblock]
== SidekiqEnt/LeaderElectionWithoutBlock

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks for potentially problematic leader election usage.

Using `Sidekiq.leader?` for long-running operations can be
problematic if leadership changes during execution. Prefer
delegating work to a job.

[#examples-sidekiqentleaderelectionwithoutblock]
=== Examples

[source,ruby]
----
# bad - long-running operation in leader check
if Sidekiq.leader?
  do_long_running_work
end

# good - enqueue job for leader work
if Sidekiq.leader?
  LeaderOnlyJob.perform_async
end
----

[#references-sidekiqentleaderelectionwithoutblock]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/LeaderElectionWithoutBlock

[#sidekiqentlimiternotreused]
== SidekiqEnt/LimiterNotReused

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that rate limiters are created as class constants for reuse.

Creating limiters inside the perform method causes Redis memory leaks
because each instance creates new Redis keys. Limiters should be
defined as class constants to be reused across job executions.

[#examples-sidekiqentlimiternotreused]
=== Examples

[source,ruby]
----
# bad - limiter created inside perform
class MyJob
  include Sidekiq::Job

  def perform
    limiter = Sidekiq::Limiter.concurrent('api', 50)
    limiter.within_limit { call_api }
  end
end

# good - limiter as class constant
class MyJob
  include Sidekiq::Job
  API_LIMITER = Sidekiq::Limiter.concurrent('api', 50, wait_timeout: 0)

  def perform
    API_LIMITER.within_limit { call_api }
  end
end

# good - dynamic limiter name (user-specific)
class MyJob
  include Sidekiq::Job

  def perform(user_id)
    limiter = Sidekiq::Limiter.concurrent("api-#{user_id}", 10)
    limiter.within_limit { call_api_for_user(user_id) }
  end
end
----

[#references-sidekiqentlimiternotreused]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/LimiterNotReused

[#sidekiqentlimiterwithoutlocktimeout]
== SidekiqEnt/LimiterWithoutLockTimeout

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that concurrent limiters specify lock_timeout option.

Without lock_timeout, the default (30 seconds) may not cover jobs
with longer execution times, causing locks to expire prematurely.

[#examples-sidekiqentlimiterwithoutlocktimeout]
=== Examples

[source,ruby]
----
# bad - no lock_timeout specified
LIMITER = Sidekiq::Limiter.concurrent('erp', 50, wait_timeout: 0)

# good - explicit lock_timeout
LIMITER = Sidekiq::Limiter.concurrent('erp', 50, wait_timeout: 0, lock_timeout: 120)
----

[#references-sidekiqentlimiterwithoutlocktimeout]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/LimiterWithoutLockTimeout

[#sidekiqentlimiterwithoutwaittimeout]
== SidekiqEnt/LimiterWithoutWaitTimeout

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that rate limiters specify wait_timeout option.

Without wait_timeout, jobs will wait indefinitely for a limit slot,
potentially blocking Sidekiq worker threads. Setting wait_timeout: 0
for class constant limiters makes the job fail fast and rely on retry.

[#examples-sidekiqentlimiterwithoutwaittimeout]
=== Examples

[source,ruby]
----
# bad - no wait_timeout specified
API_LIMITER = Sidekiq::Limiter.concurrent('api', 50)

# good - explicit wait_timeout
API_LIMITER = Sidekiq::Limiter.concurrent('api', 50, wait_timeout: 0)

# good - wait_timeout with value
API_LIMITER = Sidekiq::Limiter.concurrent('api', 50, wait_timeout: 5)
----

[#references-sidekiqentlimiterwithoutwaittimeout]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/LimiterWithoutWaitTimeout

[#sidekiqentperiodicjobinvalidcron]
== SidekiqEnt/PeriodicJobInvalidCron

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that cron expressions in periodic job registration are valid.

Invalid cron expressions will cause Sidekiq Enterprise to fail when
loading the periodic job configuration.

[#examples-sidekiqentperiodicjobinvalidcron]
=== Examples

[source,ruby]
----
# bad - invalid cron (6 fields)
config.periodic do |mgr|
  mgr.register('0 * * * * *', 'SomeJob')
end

# bad - invalid minute value
config.periodic do |mgr|
  mgr.register('60 * * * *', 'SomeJob')
end

# good - valid cron
config.periodic do |mgr|
  mgr.register('0 * * * *', 'SomeJob')
end
----

[#references-sidekiqentperiodicjobinvalidcron]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/PeriodicJobInvalidCron

[#sidekiqentperiodicjobwitharguments]
== SidekiqEnt/PeriodicJobWithArguments

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that periodic jobs do not require arguments without defaults.

Periodic jobs are scheduled by cron and cannot receive dynamic arguments
unless specified via the `args` option in the periodic registration.
A perform method requiring arguments will fail when called periodically.

[#examples-sidekiqentperiodicjobwitharguments]
=== Examples

[source,ruby]
----
# bad - requires arguments
class HourlyReportJob
  include Sidekiq::Job

  def perform(user_id)
  end
end

# good - no arguments
class HourlyReportJob
  include Sidekiq::Job

  def perform
  end
end

# good - optional arguments with defaults
class HourlyReportJob
  include Sidekiq::Job

  def perform(scope = 'all')
  end
end
----

[#references-sidekiqentperiodicjobwitharguments]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/PeriodicJobWithArguments

[#sidekiqentuniquejobtooshortttl]
== SidekiqEnt/UniqueJobTooShortTTL

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that unique jobs have sufficient TTL.

A too short unique_for TTL may expire during retries, allowing
duplicate jobs to be enqueued while the original is still retrying.

[#examples-sidekiqentuniquejobtooshortttl]
=== Examples

[source,ruby]
----
# bad - TTL too short
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 30
end

# good - adequate TTL
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 3600
end
----

[#configurable-attributes-sidekiqentuniquejobtooshortttl]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinimumTTL
| `60`
| Integer
|===

[#references-sidekiqentuniquejobtooshortttl]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/UniqueJobTooShortTTL

[#sidekiqentuniquejobwithoutttl]
== SidekiqEnt/UniqueJobWithoutTTL

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that unique jobs specify the unique_for option.

Sidekiq Enterprise unique jobs require a TTL (unique_for) to be specified.
Without it, uniqueness locks may persist indefinitely if jobs fail.

[#examples-sidekiqentuniquejobwithoutttl]
=== Examples

[source,ruby]
----
# bad - unique_until without unique_for
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_until: :start
end

# good - both unique_for and unique_until specified
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 1.hour, unique_until: :start
end
----

[#references-sidekiqentuniquejobwithoutttl]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/UniqueJobWithoutTTL

[#sidekiqentuniqueuntilmismatch]
== SidekiqEnt/UniqueUntilMismatch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.1
| -
|===

Checks that unique_until option has an appropriate value.

Using unique_until: :start may cause unexpected behavior as the lock
is released when the job starts, allowing concurrent execution
of identical jobs.

[#examples-sidekiqentuniqueuntilmismatch]
=== Examples

[source,ruby]
----
# bad - lock released on start
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 600, unique_until: :start
end

# good - default behavior (success)
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 600
end

# good - explicit success
class MyJob
  include Sidekiq::Job
  sidekiq_options unique_for: 600, unique_until: :success
end
----

[#configurable-attributes-sidekiqentuniqueuntilmismatch]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| AllowedValues
| `success`
| Array
|===

[#references-sidekiqentuniqueuntilmismatch]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqEnt/UniqueUntilMismatch
