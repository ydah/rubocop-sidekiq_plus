////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= SidekiqPro

[#sidekiqprobatchcallbackmethod]
== SidekiqPro/BatchCallbackMethod

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.4
| -
|===

Checks that batch callback methods are named correctly.

Sidekiq Pro batch callbacks require specific method names:
- `:complete` callback requires `on_complete` method
- `:success` callback requires `on_success` method
- `:death` callback requires `on_death` method

[#examples-sidekiqprobatchcallbackmethod]
=== Examples

[source,ruby]
----
# bad - callback method name is incorrect
class MyCallback
  def complete(status, options)
  end
end
batch.on(:complete, MyCallback)

# good
class MyCallback
  def on_complete(status, options)
  end
end
batch.on(:complete, MyCallback)

# good - method specified as string
batch.on(:complete, 'MyCallback#handle_complete')
----

[#references-sidekiqprobatchcallbackmethod]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/BatchCallbackMethod

[#sidekiqprobatchretryincallback]
== SidekiqPro/BatchRetryInCallback

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that jobs enqueued in batch callbacks have retry enabled.

When a batch succeeds but the callback job fails without retry,
the overall workflow may be incomplete without any automatic recovery.

[#examples-sidekiqprobatchretryincallback]
=== Examples

[source,ruby]
----
# bad - callback enqueues a job without retry
class MyCallback
  def on_success(status, options)
    FinalizeJob.perform_async(options['order_id'])
  end
end

class FinalizeJob
  include Sidekiq::Job
  sidekiq_options retry: false
end

# good - callback enqueues a job with retry enabled
class FinalizeJob
  include Sidekiq::Job
  sidekiq_options retry: 5
end
----

[#sidekiqprobatchstatuspolling]
== SidekiqPro/BatchStatusPolling

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.5
| -
|===

Checks for batch status polling anti-patterns.

Polling batch status in a loop wastes resources and can cause
issues. Use batch callbacks instead.

[#examples-sidekiqprobatchstatuspolling]
=== Examples

[source,ruby]
----
# bad - polling for status
loop do
  status = Sidekiq::Batch::Status.new(bid)
  break if status.complete?
  sleep 5
end

# good - use callbacks
batch = Sidekiq::Batch.new
batch.on(:complete, MyCallback)
batch.jobs do
  SomeJob.perform_async
end
----

[#references-sidekiqprobatchstatuspolling]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/BatchStatusPolling

[#sidekiqprobatchwithoutcallback]
== SidekiqPro/BatchWithoutCallback

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.5
| -
|===

Checks that batches have callbacks or descriptions for tracking.

Batches without callbacks or descriptions are difficult to track
and monitor. Consider adding at least one callback or a description.

[#examples-sidekiqprobatchwithoutcallback]
=== Examples

[source,ruby]
----
# bad - no callback or description
batch = Sidekiq::Batch.new
batch.jobs do
  SomeJob.perform_async
end

# good - has callback
batch = Sidekiq::Batch.new
batch.on(:complete, MyCallback)
batch.jobs do
  SomeJob.perform_async
end

# good - has description
batch = Sidekiq::Batch.new
batch.description = "Import users"
batch.jobs do
  SomeJob.perform_async
end
----

[#configurable-attributes-sidekiqprobatchwithoutcallback]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Severity
| `warning`
| String
|===

[#references-sidekiqprobatchwithoutcallback]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/BatchWithoutCallback

[#sidekiqproemptybatch]
== SidekiqPro/EmptyBatch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.4
| -
|===

Checks for batch.jobs blocks that might be empty.

Empty batches cause errors in Sidekiq Pro versions before 7.1.
Even in newer versions, creating empty batches is often unintentional.

[#examples-sidekiqproemptybatch]
=== Examples

[source,ruby]
----
# bad - block might add no jobs
batch = Sidekiq::Batch.new
batch.jobs do
  items.each do |item|
    ProcessJob.perform_async(item.id) if item.active?
  end
end

# good - ensure at least one job is added or check before creating batch
active_items = items.select(&:active?)
if active_items.any?
  batch = Sidekiq::Batch.new
  batch.jobs do
    active_items.each do |item|
      ProcessJob.perform_async(item.id)
    end
  end
end
----

[#references-sidekiqproemptybatch]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/EmptyBatch

[#sidekiqproexpiringjobwithoutttl]
== SidekiqPro/ExpiringJobWithoutTTL

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.5
| -
|===

Checks that expiring jobs have appropriate TTL values.

A TTL that is too short may cause jobs to expire before processing,
while a TTL that is too long defeats the purpose of expiring jobs.

[#examples-sidekiqproexpiringjobwithoutttl]
=== Examples

[source,ruby]
----
# bad - TTL too short
class MyJob
  include Sidekiq::Job
  sidekiq_options expires_in: 1.minute
end

# bad - TTL too long
class MyJob
  include Sidekiq::Job
  sidekiq_options expires_in: 30.days
end

# good - appropriate TTL
class MyJob
  include Sidekiq::Job
  sidekiq_options expires_in: 1.hour
end
----

[#configurable-attributes-sidekiqproexpiringjobwithoutttl]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MinimumTTL
| `300`
| Integer

| MaximumTTL
| `604800`
| Integer
|===

[#references-sidekiqproexpiringjobwithoutttl]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/ExpiringJobWithoutTTL

[#sidekiqprolargeargumentinbatch]
== SidekiqPro/LargeArgumentInBatch

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| 0.4
| -
|===

Checks for large arguments passed to jobs within a batch.

When using batches, passing large arguments to jobs is especially
problematic because it can exhaust Redis memory when many jobs
are enqueued simultaneously.

[#examples-sidekiqprolargeargumentinbatch]
=== Examples

[source,ruby]
----
# bad
batch.jobs do
  items.each do |item|
    ProcessJob.perform_async(item.attributes)
  end
end

# good
batch.jobs do
  items.each do |item|
    ProcessJob.perform_async(item.id)
  end
end
----

[#configurable-attributes-sidekiqprolargeargumentinbatch]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| MaxArraySize
| `10`
| Integer

| MaxHashSize
| `10`
| Integer
|===

[#references-sidekiqprolargeargumentinbatch]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/LargeArgumentInBatch

[#sidekiqpronestedbatchwithoutparent]
== SidekiqPro/NestedBatchWithoutParent

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Checks that nested batches have proper parent relationship.

When creating nested batches inside a batch.jobs block,
the child batch should reference the parent for proper tracking.

[#examples-sidekiqpronestedbatchwithoutparent]
=== Examples

[source,ruby]
----
# bad - nested batch without parent reference
class ProcessBatchJob
  include Sidekiq::Job

  def perform
    batch.jobs do
      child_batch = Sidekiq::Batch.new
      child_batch.jobs do
        SomeJob.perform_async
      end
    end
  end
end

# good - explicit parent reference
class ProcessBatchJob
  include Sidekiq::Job

  def perform
    parent_batch = batch
    parent_batch.jobs do
      child_batch = Sidekiq::Batch.new(parent_batch.bid)
      child_batch.jobs do
        SomeJob.perform_async
      end
    end
  end
end
----

[#sidekiqproreliabilitynotenabled]
== SidekiqPro/ReliabilityNotEnabled

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Disabled
| Yes
| No
| 0.5
| -
|===

Checks that Sidekiq Pro reliability features are enabled.

Sidekiq Pro provides `super_fetch!` and `reliable_push!` for
improved job reliability. These should be enabled in production.

[#examples-sidekiqproreliabilitynotenabled]
=== Examples

[source,ruby]
----
# bad - reliability features not enabled
Sidekiq.configure_server do |config|
  config.redis = { url: ENV['REDIS_URL'] }
end

# good - reliability features enabled
Sidekiq.configure_server do |config|
  config.redis = { url: ENV['REDIS_URL'] }
  config.super_fetch!
  config.reliable_push!
end
----

[#configurable-attributes-sidekiqproreliabilitynotenabled]
=== Configurable attributes

|===
| Name | Default value | Configurable values

| Include
| `config/initializers/sidekiq.rb`
| Array
|===

[#references-sidekiqproreliabilitynotenabled]
=== References

* https://www.rubydoc.info/gems/rubocop-sidekiq_plus/RuboCop/Cop/SidekiqPro/ReliabilityNotEnabled
